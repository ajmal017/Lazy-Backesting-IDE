<!DOCTYPE html>
<html>
<!--
    (c)2015 John Orford
    
    This file is part of Lazy Backtesting.

    Lazy Backtesting is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Lazy Backtesting is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with Lazy Backtesting.  If not, see <http://www.gnu.org/licenses/>.
-->
<head>
        
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  
        <title>Lazy Backtest IDE</title>
        
        <script type="text/javascript" src="lib/lazy.js"></script>
        <script type="text/javascript" src="lib/jstat.min.js"></script>
        <script type="text/javascript" src="lib/d3.min.js"></script>
        <script type="text/javascript" charset="utf-8" src="lib/numeric-1.2.6.min.js"></script>
       
        <script src="lib/codemirror.js"></script>
        <link rel="stylesheet" href="lib/codemirror.css">
        <script src="lib/javascript.js"></script>
        
        <script type="text/javascript" src="lib/networking2.js"></script>
        <script type="text/javascript" src="lib/utility.js"></script>
        <script type="text/javascript" src="lib/strategyHelpers.js"></script>
        <script type="text/javascript" src="lib/dataHelpers.js"></script>
       
        <style>
                #title{font-size:6em}
                #downloadResults{display:none;}
        </style>
        
</head>

<body>
        <iframe name="my_iframe" src="about:blank" style="display:none;"></iframe>

        <form autocomplete="on" target="my_iframe" action="about:blank" method='get'>

                <button id="submitButton" type="submit" style="display:none;"></button>

                <div id="title">Lazy Backtest IDE</div>

                <hr />  
                <p>1) Set the strategy's holding period</p>
                
                <div>   
                        <select id='horizon'>
                                <option value='1'>Daily</option>
                                <option value='5'>Weekly</option>
                                <option value='21' selected="selected">Monthly</option>
                                <option value='63'>Quarterly</option>
                        </select>
                </div>

                <hr />
                
                <p>2) Pull required data down from <a href='https://www.quandl.com/'>Quandl</a> by specifying sources and tickers</p>

                
                <div>
                        <select id='source2' autocomplete="on">
                                <option value='GOOG'>Google</option>
                                <option value='YAHOO'>Yahoo</option>
                                <option value='SPDJ'>S&amp;P Dow Jones</option>
                                <option value='CBOE' selected="selected">Chicago Board of Options Exchange</option>
                        </select>
                        <input type="text" id='ticker2' value='SKEW'/>
                        Yield
                        <input type="checkbox" id="yield2" value="true" autocomplete="on"/>
                        <a href='javascript:void(0)' id='addAsset2'>ADD</a>
                </div>

                <div>
                        <select id='source1' autocomplete="on">
                                <option value='GOOG'>Google</option>
                                <option value='YAHOO' selected="selected">Yahoo</option>

                                <option value='SPDJ'>S&amp;P Dow Jones</option>
                                <option value='CBOE'>Chicago Board of Options Exchange</option>
                        </select>
                        <input type="text" id='ticker1' value='INDEX_GSPC' value="true" autocomplete="on"/>
                        Yield
                        <input type="checkbox" id="yield1" autocomplete="on"/>
                        <a href='javascript:void(0)' id='addAsset1'>ADD</a>
                </div>
                
                <div>
                        <select id='source3' autocomplete="on">
                                <option value='GOOG'>Google</option>
                                <option value='YAHOO' selected="selected">Yahoo</option>
                                <option value='SPDJ'>S&amp;P Dow Jones</option>
                                <option value='CBOE'>Chicago Board of Options Exchange</option>
                        </select>
                        <input type="text" id='ticker3' value='INDEX_IRX' value="true" autocomplete="on"/>
                        Yield
                        <input type="checkbox" id="yield3" autocomplete="on" checked />
                        <a href='javascript:void(0)' id='addAsset3'>ADD</a>
                </div>
                
                <hr />  
                
                <div id="availableData"></div>
                
                        

                <hr />
                
                <p>3) Code your strategy in the browser</p>

                <div id="code"></div>
                
                <hr /> 
                
                <p>4) Hit the back test link</p>
                
                <p><a href='javascript:void(0)' id="backTest">Back Test</a></p>
                
                
                <div id="messages"></div>
                
                
                <a id='downloadResults'>Download CSV file</a>
                
                <hr />

                <p>Optional: input a Quandl key for unlimited & free data</p>
                <div>                
                        <input type="password" id='key' autocomplete="on"/>
                </div>
                
                <hr />

                <p><a href='http://blog.johnorford.com/2015/04/29/lazy-backtesting-update/'>API Details</a></p>

                <p>Need help? Watch the screencast:</p>
                
                <!--
                <iframe width="960" height="720" src="https://www.youtube-nocookie.com/embed/dWYPNS_mc6U?rel=0" frameborder="0" allowfullscreen></iframe>
                -->
        </form>
</body>

        <script>
                "use strict"
        
                //*****************************************************
                //globals        
                
                var data = [];
                //var fd = null;
                var cd = null;
                
                //*****************************************************
                //set listeners
                
                document.getElementById('addAsset1')
                        .addEventListener(
                                "click", 
                                function(){addAsset(1);}
                                );
                document.getElementById('addAsset2')
                        .addEventListener(
                                "click", 
                                function(){addAsset(2);}
                                );
                document.getElementById('addAsset3')
                        .addEventListener(
                                "click", 
                                function(){addAsset(3);}
                                );
                document.getElementById('backTest')
                        .addEventListener(
                                "click", 
                                function(){setBackTestListener();}
                                );
                
                //*****************************************************
                function setBackTestListener(){
                        var code = editor.getValue();
                        var js = 
                                //setup strategyLogic function
                                "var strategyLogic = function(data){var weight = new Object();\n"+
                                code+"\n"+
                                "return weight;}\n"+
                                //kick off backtest
                                "backTest();\n";
                        var s = document.createElement('script');
                        s.textContent = js;
                        document.body.appendChild(s);
                        }
                
                //*****************************************************
                
                document.getElementById('horizon')
                        .addEventListener(
                                "change", 
                                //format data if clean data is available
                                function(){
                                        var horizon = +document.getElementById('horizon').value;
                                        //cd != null ? fd = cd.formatData(horizon) : null;
                                        //"Data formatted".write("","availableData");
                                        }
                                );
        
                //*****************************************************
                //for some reason I can't put this in a seperate 'utility.js' file...
                   
                Object.defineProperty(
                        Object.prototype, 
                        'print',
                        {
                                value: function(){ return console.log(this); },
                                writable: true,
                                configurable: true,
                                enumerable: false
                                }
                        );
                
        
                //*****************************************************
                //Code Mirror
                
                var editor = CodeMirror(
                        document.getElementById("code"), 
                        {
                          value:
                                "//The 'data' object stores all the inputs needed to allocate assets.\n"+
                                "//data.SKEW is the CBOE skew index time series.\n"+
                                "\n"+

                                "//data.INDEX_GSPC is the S&P 500 price time series.\n\n"+

                                "//This strategy uses the latest skew change as an indicator,\n"+
                                "//which sets asset weights for the next period.\n"+
                                "//In this case, the S&P 500 is weighted long or short.\n\n"+
                        
                                "//The indicator sets asset weights for the next period.\n"+
                                "//We get the previous two monthly levels and generate a return.\n"+
                                
                                "var skewReturn = data.SKEW.monthly().lookback(2).returns()[0];\n"+
                                
	                        "weight.INDEX_GSPC = -skewReturn;\n\n"+
                                
                                "//13 week t-bill yield index used to calculate Sharpe ratio. Scaled for a monthly horizon\n"+
                                "weight.INDEX_IRX = -weight.INDEX_GSPC*(4/13);\n"
                                ,
                          mode: "javascript",
                          lineNumbers: true
                        }
                        );
                

                //*****************************************************
                    
                    
                var formatCleanWorker = null;
                
                
                function setUpformatCleanWorker(){
                        formatCleanWorker != null ? formatCleanWorker.terminate() : null;
                        
                        //one worker pulls in data & adds to prev data
                        //one worker cleans & formats
                        //one worker formats
                        //one worker backtests
                        
                        //horizon maps cleansed to formatted data
                        //data 'pulls' -> pulls, adds to global, cleans & formats 
                        //backtest just backtests
                        
                        //any thread can be terminated apart from pulling data in
                        //if a new formatting job comes along it prob has up-to-date info
                        //so kill the old one and run the up-to-date version
                        
                        formatCleanWorker = new Worker('formatWorker.js');
                
                        formatCleanWorker.addEventListener(
                                'message', 
                                function(e) {
                                        //save down global data once available
                                        cd = e.data;
                                        
                                        //save down truncated data
                                        //data = Object.keys(cd).map(function(k){return {ticker:cd[k][0].ticker, prices:cd[k]};});
                                        
                                        "Data cleaned".write("","availableData");
                                        //fd = Lazy(e.data[1]);
                                        //"Data formatted".write("","availableData");
                                        }
                                , false
                                );

                        
                        }
                    
                //always running, never terminated
                //multiple adds queue up behind each other
                var addMarketDataWorker = new Worker('addMarketDataWorker.js');
                      
                //after
                addMarketDataWorker.addEventListener(
                        'message', 
                        function(e) {
                                //send data back to parent thread
                                "OK".write("Status:","availableData");
                                
                                var d = e.data;
                                
                                //global raw data saved down
                                data = data.concat({ticker: d.ticker, prices: d.prices});

                                setUpformatCleanWorker();

                                //send worker data
                                formatCleanWorker.postMessage([data,d.horizon]);
                                }
                        , false
                        );
                         
                //*****************************************************
                //add assets
                //call for data
                function addAsset(no){
                        var ticker = document.getElementById('ticker'+no).value;
                        var y = document.getElementById('yield'+no).checked;
                        var horizon = document.getElementById('horizon').value;
                        var source = document.getElementById('source'+no).value;
                        
                        var key = document.getElementById('key').value;
                        key = 'Fp6cFhibc5xvL2pN3dnu';
                        
                        if (data.filter(
                                function(i){
                                        return i.ticker === ticker;
                                        }
                                )
                                .length === 0
                                ) {                                                                
                                ticker.write("Requesting prices for:","availableData");
                                
                                //send above vars to worker
                                addMarketDataWorker.postMessage(
                                        {ticker:ticker,y:y,horizon:horizon,key:key,source:source}
                                        );
                                }
                        else    {
                                "".write("Ticker already added","availableData");
                                }
                        }
                
                
                //reduce
                
                
                //*****************************************************
                //only run after add asset - horizon doesn't affect this
                //remove mismatching dates
                //return checking (i.e. that returns encompass the required horizon) should be done later
                //parallelable?
                //if run in asynced process as a whole job (not chunks) kill once newer cleandata has been kicked off... only one should run at any time.
                                                                
                //*****************************************************
                
                function backTest(){
                
                        //cd reduce, and then format on the fly?
                        //no need to have fd at all?   
                        
                        var horizon = +document.getElementById('horizon').value;
                        
                        //[...,{future:,history:},...]
                        //build from bottom up
                        //foldr
                        //future is a horizon
                        
                        
                        cd      .reverse()
                                .reduce(
                                        function(a,c){
                                                var rr = {};
                                                rr.sofar = a.sofar.concat([c]);
                                                rr.result = a   .result
                                                                .concat( 
                                                                        [
                                                                        Lazy(a.sofar)
                                                                                .flatten()
                                                                                .groupBy(
                                                                                        function(j){
                                                                                                return j.ticker;
                                                                                                }
                                                                                        )
                                                                                .toArray()
                                                                                .reduce(
                                                                                        function(a,j){
                                                                                                var rrr = {};
                                                                                                a[j[0].ticker] = j;
                                                                                                return a;
                                                                                                }
                                                                                        ,[]
                                                                                        )
                                                                        ]
                                                                        )
                                                                ;
                                                /*
                                                //throws an error if strategy logic asks for more data than available
                                                try {
                                                        var future = [ a.sofar[0], a.sofar[horizon] ].returns();
                                                        var history = a.slice(horizon+1);
                                                
                                                        rr.result = a    .result
                                                                        .concat({future:future,history:history});
                                                        
                                                        var currentWeights = strategyLogic(history); 
                                                        //build new object
                                                        var rr = {};
                                                        rr.date = c[0].date;
                                                        rr = Object
                                                                .keys(future)
                                                                .reduce(
                                                                        function(b,k){
                                                                                b[k+"_return"] = c.future[k][0];
                                                                                return b;
                                                                                }
                                                                        ,rr
                                                                        );
                                                        Object  .keys(currentWeights)
                                                                .forEach(
                                                                        function(k){
                                                                                rr[k+"_weight"] = currentWeights[k];
                                                                                }
                                                                        );
                                                        var r = Object
                                                                .keys(currentWeights)
                                                                .reduce(
                                                                        function(aa,k){
                                                                                return aa+(currentWeights[k]*c.future[k]);
                                                                                }
                                                                        ,0
                                                                        );
                                                        rr.STRAT_return = r;
                                                        return a.concat(rr);
                                                        
                                                        }
                                                
                                                //thrown if we ran out of data
                                                catch(err){
                                                        //do nothing
                                                        }
                                                */
                                                
                                                //return strategy return or nothing if not enough data / or exception
                                                //and return returns so far!
                                                return rr;
                                                }
                                        //rets so far, summary
                                        , {sofar:[],result:[]}
                                        )
                                        /*
                                        .result
                                        .map(
                                                function(i){
                                                        return i.reduce(
                                                                function(a,j){
                                                                        var rrr = {};
                                                                        a[j[0].ticker] = j; 
                                                                
                                                                        return a;
                                                                        }
                                                                ,[]
                                                                );
                                                        }
                                                )
                                        */
                                .print();
                        
                        /*
                        fd      .reduce(
                                        function(a,c){
                                                //throws an error if strategy logic asks for more data than available
                                                try {
                                                        var currentWeights = strategyLogic(c.history); 
                                                        //build new object
                                                        var rr = {};
                                                        rr.date = c.date;
                                                        rr = Object
                                                                .keys(c.future)
                                                                .reduce(
                                                                        function(b,k){
                                                                                b[k+"_return"] = c.future[k][0];
                                                                                return b;
                                                                                }
                                                                        ,rr
                                                                        );
                                                        Object  .keys(currentWeights)
                                                                .forEach(
                                                                        function(k){
                                                                                rr[k+"_weight"] = currentWeights[k];
                                                                                }
                                                                        );
                                                        var r = Object
                                                                .keys(currentWeights)
                                                                .reduce(
                                                                        function(aa,k){
                                                                                return aa+(currentWeights[k]*c.future[k]);
                                                                                }
                                                                        ,0
                                                                        );
                                                        rr.STRAT_return = r;
                                                        return a.concat(rr);
                                                        }
                                                
                                                //thrown if we ran out of data
                                                catch(err){
                                                        return a;
                                                        }
                                                }
                                        ,[]
                                        )
                                .printResults(horizon); 
                                */       
                        }
                
                //*****************************************************
                
                Array.prototype.printResults = function(horizon){
                        
                        //can change between data generation and call
                        "**********************************************************************".print();
                        var inCSVFormat = 
                                d3.csv.formatRows(
                                        this.reduce(
                                                        function(a,c){
                                                                //return values of object
                                                                //converting into array
                                                                //keys are top and column headers
                                                                return a.concat( [ Lazy(c).values().toArray() ] );
                                                                }
                                                        , [ Object.keys(this[0]) ]
                                                )
                                        );
                        
                        
                        //append link
                        document.getElementById('downloadResults').href = "data:text/csv;charset=utf-8," + escape(inCSVFormat); 
                        document.getElementById('downloadResults').style.display = 'block';
                        
                        //get returns
                        var stratRets = 
                                this.map(
                                        function(i){
                                                return i.STRAT_return;
                                                }
                                        );
                        
                        //annualise
                        var period = 252/horizon;

                        "Total Return:".print();
                        var tot = stratRets.reduce(function(acc,cur){return acc + cur;},0);
                        tot.toLocaleString().print();
        
                        "Average:".print();
                        var av = (period*tot/stratRets.length);
                        av.toLocaleString().print();

                        "SD:".print();
                        var sd = (jStat.stdev(stratRets,true)*Math.sqrt(period));
                        sd.toLocaleString().print();

                        "Sharpe:".print();
                        var sharpe = av/sd;
                        sharpe.toLocaleString().print();

                        "Median:".print();
                        (jStat.median(stratRets)*period).toLocaleString().print();

                        "MAD:".print();
                        (jStat.meddev(stratRets)*Math.sqrt(period)).toLocaleString().print();

                        "Skew:".print();
                        var skew = jStat.skewness(stratRets);
                        skew.toLocaleString().print()
        
                        "Sample Size:".print();
                        stratRets.length.toLocaleString().print();
        
                        //years to profitiability
                        //chunk returns by 1, 2, 3, etc years
                        //return no of years where all returns are positive
                        var years = Math.floor(stratRets.length/period)+1;
                        
                        var rr = Lazy    .range(1,years)
                                .map(
                                        function(i){
                                                //number of chunks
                                                var chunks = Math.floor(stratRets.length/(i*period));
                                                
                                                var chunkSize = i * period;
                                                
                                                //rets wo any leftovers
                                                var stratRets2 = Lazy(stratRets).take(chunks*chunkSize);
                                                
                                                var r = stratRets2
                                                        .chunk(chunkSize)
                                                        .map(
                                                                function(j){
                                                                        return j
                                                                                .reduce(
                                                                                        function(a,c){
                                                                                                return a+c;
                                                                                                }
                                                                                        ,0);
                                                                        }
                                                                )
                                                        //reduce to number of profitable and not periods
                                                        //expected is 50/50
                                                        //100 is maximum
                                                        .toArray();
                                                
                                                return r;
                                                }
                                        )
                                .reduce(
                                        function(a,i){
                                                var l = i
                                                        .filter(
                                                                function(j){
                                                                        return j>0;
                                                                        }
                                                                )
                                                        .length;
                                                
                                                if (a[a.length-1].years === 0){
                                                        return [{profitPercent:l/i.length,years:a[a.length-1].years+1}];
                                                        }
                                                else {
                                                        return a.concat({profitPercent:l/i.length,years:a[a.length-1].years+1});
                                                        }
                                        
                                                }
                                        ,[{profitPercent:null,years:0}]
                                        )
                                ;
                        
                        "Years to Profitability".print();    
                        //expected years to profitability
                        "Expected".print();
                        var expectedWait = Lazy(rr).find(function(i){return i.profitPercent > 0.5});
                        
                        //expectedWait.profitPercent.print();
                        
                        expectedWait === undefined ? expectedWait = "N/A" : expectedWait = expectedWait.years ;
                        expectedWait.print();
                        
                        //max years to profitability
                        "Max".print();
                        var maxWait = Lazy(rr).find(function(i){return i.profitPercent === 1});
                        maxWait === undefined ? maxWait = "N/A" : maxWait = maxWait.years ;
                        maxWait.print();
                        
                        //standardised 10 year sharpe
                        /*
                        var probLoss = 1-jStat.studentt.cdf(sharpe*Math.pow(years,0.5),years - 1);
                        "Yearly Loss Probability".print();
                        probLoss.toLocaleString().print();
                        
                        
                        var std10YrSharpe = jStat.studentt.inv(1-probLoss,9)/Math.sqrt(10);
                        "Standardised Sharpe (10 year backtest history)".print();
                        std10YrSharpe.toLocaleString().print();
                        */
                        //***************************************************************
                        //remove pre-existing nodes
                        var node = document.getElementById("messages");
                        while (node.hasChildNodes()) {
                                node.removeChild(node.lastChild);
                                }
                        //***************************************************************
        
                        tot.toLocaleString().write("Total Return:");
                        av.toLocaleString().write("Average Return:");
                        sd.toLocaleString().write("Std Dev:");
                        sharpe.toLocaleString().write("Sharpe:");
                        //std10YrSharpe.toLocaleString().write("Standardised Sharpe (10 year backtest history):");
                        skew.toLocaleString().write("Skew:")
                        stratRets.length.toLocaleString().write("Sample Size:");
                        
                        //probLoss.toLocaleString().write("Yearly Loss Probability:");
                        maxWait.write("Max Wait to Profitability:"); 
                        
                        }
                
        </script>
</html>
